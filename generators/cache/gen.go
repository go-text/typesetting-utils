package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"path/filepath"
)

// CLI usage : go run generators/cache/gen.go -- ../typesetting

// parametrize bit sizes
type sizeSpec struct {
	keyBits   int
	valueBits int
	cacheBits int
}

// excluded
func (ss sizeSpec) maxValue() int {
	return 1 << ss.valueBits
}

// excluded
func (ss sizeSpec) maxKey() int {
	return 1 << ss.keyBits
}

// element size depends on keyBits + valueBits - cacheBits
func (ss sizeSpec) elemType() string {
	v := ss.keyBits + ss.valueBits - ss.cacheBits
	switch v {
	case 8:
		return "uint8"
	case 16:
		return "uint16"
	case 32:
		return "uint32"
	default:
		panic("unsupported sizes")
	}
}

func (ss sizeSpec) keyType() string {
	if ss.keyBits <= 8 {
		return "uint8"
	} else if ss.keyBits <= 16 {
		return "uint16"
	} else {
		return "uint32"
	}
}

func (ss sizeSpec) cacheType() string {
	return fmt.Sprintf("cache%[1]d_%[2]d_%[3]d", ss.keyBits, ss.valueBits, ss.cacheBits)
}

func (ss sizeSpec) code() string {
	return fmt.Sprintf(template, ss.cacheType(), ss.elemType(),
		ss.keyBits, ss.valueBits, ss.cacheBits, ss.maxKey(), ss.maxValue(), ss.keyType(),
	)
}

const comment = `
/* Implements caches for integers key->value functions.
 *
 * The cache is a fixed-size array of 8-bit, 16-bit or 32-bit integers,
 * typically 256 elements.
 *
 * The key is split into two parts: the cache index (high bits)
 * and the rest (low bits).
 *
 * The memory layout is the following :
 * 	KEY 		= <key bits - cache bits><cache bits>
 * 	VALUE 	= <key bits - cache bits><value bits>
 * with the constraints
 *	KEY in [0, 2^key bits[
 *	VALUE in [0, 2^value bits[
 *
 * The cache index is used to index into the array. The array
 * member is an integer that is used BOTH
 * to store the low bits of the key, and the value.
 *
 * The value is stored in the least significant bits of the integer.
 * The low bits of the key are stored in the most significant bits
 * of the integer.
 *
 * A cache hit is detected by comparing the low bits of the key
 * with the high bits of the integer at the array position indexed
 * by the high bits of the key. If they match, the value is extracted
 * from the least significant bits of the integer and returned.
 * Otherwise, a cache miss is reported.
 *
 * Cache operations (storage and retrieval) involve just a few
 * arithmetic operations and a single memory access.
 */
`

const template = `
// %[1]s is a cache for integer (key, value) pairs,
// with 0 <= key < %[6]d and 0 <= value < %[7]d
type %[1]s [1 << %[5]d]%[2]s

// clear should be used as init function
func (c *%[1]s) clear() {
	for i := range c {
		c[i] = ^%[2]s(0)
	}
}

func (c %[1]s) get(key %[8]s) (%[2]s, bool) {
	k := key & ((1 << %[5]d) - 1)
	v := c[k]
	if v == ^%[2]s(0) || (v>>%[4]d) != %[2]s(key>>%[5]d) {
		return 0, false
	}
	return v & ((1 << %[4]d) - 1), true
}

func (c *%[1]s) set(key %[8]s, value %[2]s) {
	if (key>>%[3]d) != 0 || (value>>%[4]d) != 0 { /* overflows */
		return
	}
	c.setUnchecked(key, value)
}

// assumes key < %[6]d and value < %[7]d
func (c *%[1]s) setUnchecked(key %[8]s, value %[2]s) {
	k := key & ((1 << %[5]d) - 1)
	v := (%[2]s(key >> %[5]d) << %[4]d) | value
	c[k] = v
}

`

func main() {
	flag.Parse()
	outDir := flag.Arg(0)
	if outDir == "" {
		log.Fatal("missing ouput directory")
	}

	// font/cmap
	code1 := `package font

// Code generated by typesetting-utils/generators/cache/gen.go. DO NOT EDIT.
` + comment + sizeSpec{21, 19, 8}.code()

	// harbuzz/caches
	code2 := `package harfbuzz

// Code generated by typesetting-utils/generators/cache/gen.go. DO NOT EDIT.
` + comment
	for _, sizes := range []sizeSpec{
		{15, 8, 7},
		// {14, 1, 7}, // not used for now
		{21, 3, 8},
	} {
		code2 += sizes.code()
	}

	outFile1 := filepath.Join(outDir, "font/cmap_cache.go")
	w, err := os.Create(outFile1)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fmt.Fprintln(w, code1); err != nil {
		log.Fatal(err)
	}
	if err := w.Close(); err != nil {
		log.Fatal(err)
	}
	exec.Command("goimports", "-w", outFile1).Run()

	outFile2 := filepath.Join(outDir, "harfbuzz/caches.go")
	w, err = os.Create(outFile2)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fmt.Fprintln(w, code2); err != nil {
		log.Fatal(err)
	}
	if err := w.Close(); err != nil {
		log.Fatal(err)
	}
	exec.Command("goimports", "-w", outFile2).Run()
}
